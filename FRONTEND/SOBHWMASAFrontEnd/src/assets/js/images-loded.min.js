class EvEmitter {
  constructor() {
      this._events = {};
      this._onceEvents = {};
  }

  on(event, callback) {
      if (!event || !callback) return;
      this._events[event] = this._events[event] || [];
      if (!this._events[event].includes(callback)) {
          this._events[event].push(callback);
      }
  }

  once(event, callback) {
      if (!event || !callback) return;
      this.on(event, callback);
      this._onceEvents[event] = this._onceEvents[event] || {};
      this._onceEvents[event][callback] = true;
  }

  off(event, callback) {
      const listeners = this._events[event];
      if (listeners) {
          const index = listeners.indexOf(callback);
          if (index !== -1) listeners.splice(index, 1);
      }
  }

  emitEvent(event, args = []) {
      const listeners = this._events[event];
      if (!listeners || listeners.length === 0) return;

      let i = 0;
      while (i < listeners.length) {
          const callback = listeners[i];
          const isOnce = this._onceEvents[event]?.[callback];

          if (isOnce) {
              this.off(event, callback);
              delete this._onceEvents[event][callback];
          }

          callback.apply(this, args);
          if (!isOnce) i++;
      }
  }

  allOff() {
      this._events = {};
      this._onceEvents = {};
  }
}

class ImageChecker extends EvEmitter {
  constructor(image) {
      super();
      this.img = image;
  }

  check() {
      if (this.img.complete && this.img.naturalWidth !== undefined) {
          this.confirm(this.img.naturalWidth > 0, "naturalWidth");
      } else {
          this.proxyImage = new Image();
          this.proxyImage.addEventListener("load", this.onload.bind(this));
          this.proxyImage.addEventListener("error", this.onerror.bind(this));

          this.img.addEventListener("load", this.onload.bind(this));
          this.img.addEventListener("error", this.onerror.bind(this));

          this.proxyImage.src = this.img.src;
      }
  }

  confirm(isLoaded, message) {
      this.isLoaded = isLoaded;
      this.emitEvent("progress", [this, this.img, message]);
  }

  onload() {
      this.confirm(true, "onload");
      this.unbindEvents();
  }

  onerror() {
      this.confirm(false, "onerror");
      this.unbindEvents();
  }

  unbindEvents() {
      this.proxyImage.removeEventListener("load", this.onload);
      this.proxyImage.removeEventListener("error", this.onerror);
      this.img.removeEventListener("load", this.onload);
      this.img.removeEventListener("error", this.onerror);
  }
}

class BackgroundImageChecker extends ImageChecker {
  constructor(url, element) {
      super(new Image());
      this.url = url;
      this.element = element;
  }

  check() {
      this.img.src = this.url;
      this.img.addEventListener("load", this.onload.bind(this));
      this.img.addEventListener("error", this.onerror.bind(this));

      if (this.img.complete) {
          this.confirm(this.img.naturalWidth > 0, "naturalWidth");
          this.unbindEvents();
      }
  }
}

class ImagesLoaded extends EvEmitter {
  constructor(elements, options = {}, callback) {
      super();
      this.elements = Array.isArray(elements) ? elements : [elements];
      this.options = { ...options };
      if (typeof callback === "function") this.on("always", callback);

      this.images = [];
      this.getImages();
      setTimeout(() => this.check(), 0);
  }

  getImages() {
      this.elements.forEach((element) => {
          this.addElementImages(element);
      });
  }

  addElementImages(element) {
      if (element.nodeName === "IMG") this.addImage(element);

      if (this.options.background === true) {
          this.addElementBackgroundImages(element);
      }

      const nodeTypes = { 1: true, 9: true, 11: true };
      if (nodeTypes[element.nodeType]) {
          const imgElements = element.querySelectorAll("img");
          imgElements.forEach((img) => this.addImage(img));

          if (typeof this.options.background === "string") {
              const backgroundElements = element.querySelectorAll(this.options.background);
              backgroundElements.forEach((bg) => this.addElementBackgroundImages(bg));
          }
      }
  }

  addElementBackgroundImages(element) {
      const style = getComputedStyle(element);
      const matches = [...style.backgroundImage.matchAll(/url\((['"])?(.*?)\1\)/gi)];

      matches.forEach((match) => {
          if (match[2]) this.addBackground(match[2], element);
      });
  }

  addImage(img) {
      const checker = new ImageChecker(img);
      this.images.push(checker);
  }

  addBackground(url, element) {
      const checker = new BackgroundImageChecker(url, element);
      this.images.push(checker);
  }

  check() {
      this.progressedCount = 0;
      this.hasAnyBroken = false;

      if (this.images.length === 0) {
          this.complete();
          return;
      }

      this.images.forEach((imageChecker) => {
          imageChecker.once("progress", this.progress.bind(this));
          imageChecker.check();
      });
  }

  progress(imageChecker, img, message) {
      this.progressedCount++;
      this.hasAnyBroken = this.hasAnyBroken || !imageChecker.isLoaded;

      this.emitEvent("progress", [this, imageChecker, img]);

      if (this.progressedCount === this.images.length) {
          this.complete();
      }
  }

  complete() {
      const event = this.hasAnyBroken ? "fail" : "done";
      this.emitEvent(event, [this]);
      this.emitEvent("always", [this]);
  }
}

// jQuery Plugin
function makeJQueryPlugin($) {
  if (!$) return;
  $.fn.imagesLoaded = function (options, callback) {
      return new ImagesLoaded(this, options, callback);
  };
}

// Auto-detect jQuery
if (typeof window !== "undefined" && window.jQuery) {
  makeJQueryPlugin(window.jQuery);
}

// Export as a module if applicable
if (typeof module !== "undefined" && module.exports) {
  module.exports = ImagesLoaded;
} else {
  window.ImagesLoaded = ImagesLoaded;
}
