/*!
 * Validator v0.8.1 for Bootstrap 3, by @1000hz
 * Copyright 2015 Cina Saffary
 * Licensed under http://opensource.org/licenses/MIT
 *
 * https://github.com/1000hz/bootstrap-validator
 */

+function ($) {
  "use strict";

  function Validator(element, options) {
      this.$element = $(element);
      this.options = options;
      options.errors = $.extend({}, Validator.DEFAULTS.errors, options.errors);

      for (var key in options.custom) {
          if (!options.errors[key]) {
              throw new Error("Missing default error message for custom validator: " + key);
          }
      }

      $.extend(Validator.VALIDATORS, options.custom);
      this.$element.attr("novalidate", true);
      this.toggleSubmit();

      this.$element
          .on("input.bs.validator change.bs.validator focusout.bs.validator", $.proxy(this.validateInput, this))
          .on("submit.bs.validator", $.proxy(this.onSubmit, this));

      this.$element.find("[data-match]").each(function () {
          var $this = $(this);
          var target = $this.data("match");

          $(target).on("input.bs.validator", function () {
              if ($this.val()) {
                  $this.trigger("input.bs.validator");
              }
          });
      });
  }

  Validator.DEFAULTS = {
      delay: 500,
      html: false,
      disable: true,
      custom: {},
      errors: {
          match: "Does not match",
          minlength: "Not long enough"
      },
      feedback: {
          success: "glyphicon-ok",
          error: "glyphicon-warning-sign"
      }
  };

  Validator.VALIDATORS = {
      native: function ($el) {
          var el = $el[0];
          return el.checkValidity ? el.checkValidity() : true;
      },
      match: function ($el) {
          var target = $el.data("match");
          return !$el.val() || $el.val() === $(target).val();
      },
      minlength: function ($el) {
          var minLength = $el.data("minlength");
          return !$el.val() || $el.val().length >= minLength;
      }
  };

  Validator.prototype.validateInput = function (event) {
      var $el = $(event.target);
      var previousErrors = $el.data("bs.validator.errors");

      if ($el.is('[type="radio"]')) {
          $el = this.$element.find('input[name="' + $el.attr("name") + '"]');
      }

      this.$element.trigger(event = $.Event("validate.bs.validator", { relatedTarget: $el[0] }));

      if (event.isDefaultPrevented()) return;

      var self = this;
      this.runValidators($el).done(function (errors) {
          $el.data("bs.validator.errors", errors);

          if (errors.length) {
              self.showErrors($el);
          } else {
              self.clearErrors($el);
          }

          if (previousErrors && errors.toString() !== previousErrors.toString()) {
              var eventName = errors.length
                  ? "invalid.bs.validator"
                  : "valid.bs.validator";

              self.$element.trigger($.Event(eventName, { relatedTarget: $el[0], detail: errors }));
          }

          self.toggleSubmit();
          self.$element.trigger($.Event("validated.bs.validator", { relatedTarget: $el[0] }));
      });
  };

  Validator.prototype.runValidators = function ($el) {
      var self = this;
      var errors = [];
      var deferred = $.Deferred();
      var options = this.options;

      function getErrorMessage(key) {
          return $el.data(key + "-error") || $el.data("error") || (key === "native" && $el[0].validationMessage) || options.errors[key];
      }

      if ($el.data("bs.validator.deferred")) {
          $el.data("bs.validator.deferred").reject();
      }

      $el.data("bs.validator.deferred", deferred);

      $.each(Validator.VALIDATORS, function (key, validator) {
          if (($el.data(key) || key === "native") && !validator.call(self, $el)) {
              var errorMessage = getErrorMessage(key);
              if (!errors.includes(errorMessage)) {
                  errors.push(errorMessage);
              }
          }
      });

      if (!errors.length && $el.val() && $el.data("remote")) {
          this.defer($el, function () {
              var data = {};
              data[$el.attr("name")] = $el.val();

              $.get($el.data("remote"), data)
                  .fail(function (_, __, error) {
                      errors.push(getErrorMessage("remote") || error);
                  })
                  .always(function () {
                      deferred.resolve(errors);
                  });
          });
      } else {
          deferred.resolve(errors);
      }

      return deferred.promise();
  };

  Validator.prototype.validate = function () {
      var previousDelay = this.options.delay;
      this.options.delay = 0;
      this.$element.find(':input:not([type="submit"], button):enabled:visible').trigger("input.bs.validator");
      this.options.delay = previousDelay;
      return this;
  };

  Validator.prototype.showErrors = function ($el) {
      var self = this;
      var method = this.options.html ? "html" : "text";

      this.defer($el, function () {
          var $group = $el.closest(".form-group");
          var $errorBlock = $group.find(".help-block.with-errors");
          var $feedback = $group.find(".form-control-feedback");
          var errors = $el.data("bs.validator.errors");

          if (errors.length) {
              var errorList = $("<ul/>").addClass("list-unstyled").append($.map(errors, function (error) {
                  return $("<li/>")[method](error);
              }));

              if ($errorBlock.data("bs.validator.originalContent") === undefined) {
                  $errorBlock.data("bs.validator.originalContent", $errorBlock.html());
              }

              $errorBlock.empty().append(errorList);
              $group.addClass("has-error");

              if ($feedback.length) {
                  $feedback.removeClass(self.options.feedback.success)
                      .addClass(self.options.feedback.error)
                      .closest(".form-group")
                      .removeClass("has-success");
              }
          }
      });
  };

  Validator.prototype.clearErrors = function ($el) {
      var $group = $el.closest(".form-group");
      var $errorBlock = $group.find(".help-block.with-errors");
      var $feedback = $group.find(".form-control-feedback");

      $errorBlock.html($errorBlock.data("bs.validator.originalContent"));
      $group.removeClass("has-error");

      if ($feedback.length) {
          $feedback.removeClass(this.options.feedback.error)
              .addClass(this.options.feedback.success)
              .closest(".form-group")
              .addClass("has-success");
      }
  };

  Validator.prototype.hasErrors = function () {
      return !!this.$element.find(':input:not([type="submit"], button):enabled:visible')
          .filter(function () {
              return !!($(this).data("bs.validator.errors") || []).length;
          }).length;
  };

  Validator.prototype.onSubmit = function (event) {
      this.validate();
      if (this.isIncomplete() || this.hasErrors()) {
          event.preventDefault();
      }
  };

  Validator.prototype.toggleSubmit = function () {
      if (this.options.disable) {
          var $submitButtons = $('button[type="submit"], input[type="submit"]').filter('[form="' + this.$element.attr("id") + '"]')
              .add(this.$element.find('input[type="submit"], button[type="submit"]'));

          $submitButtons.toggleClass("disabled", this.isIncomplete() || this.hasErrors());
      }
  };

  Validator.prototype.destroy = function () {
      this.$element
          .removeAttr("novalidate")
          .removeData("bs.validator")
          .off(".bs.validator")
          .find(':input:not([type="submit"], button):enabled:visible')
          .off(".bs.validator")
          .removeData(["bs.validator.errors", "bs.validator.deferred"]);

      return this;
  };

  $.fn.validator = function (option) {
      return this.each(function () {
          var $this = $(this);
          var data = $this.data("bs.validator");
          var options = $.extend({}, Validator.DEFAULTS, $this.data(), typeof option === "object" && option);

          if (!data && option !== "destroy") {
              $this.data("bs.validator", new Validator(this, options));
          }

          if (typeof option === "string") {
              data[option]();
          }
      });
  };

  $(window).on("load", function () {
      $('form[data-toggle="validator"]').each(function () {
          $(this).validator();
      });
  });

}(jQuery);
